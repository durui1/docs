(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{524:function(r,a,s){r.exports=s.p+"assets/img/e0c60b4606711fc4a0b6faf03230247a.97c54723.png"},525:function(r,a,s){r.exports=s.p+"assets/img/frc-365faceb5697f04f31399937c059c162.005b53a7.png"},526:function(r,a,s){r.exports=s.p+"assets/img/926dfc549b06d280a37397f9fd49bf9d.3438696c.jpg"},545:function(r,a,s){"use strict";s.r(a);var t=s(6),e=Object(t.a)({},(function(){var r=this,a=r.$createElement,t=r._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[t("h1",{attrs:{id:"spring"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring"}},[r._v("#")]),r._v(" Spring")]),r._v(" "),t("h2",{attrs:{id:"什么是-spring-框架"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是-spring-框架"}},[r._v("#")]),r._v(" 什么是 Spring 框架?")]),r._v(" "),t("p",[r._v("Spring 是一款开源的轻量级 Java 开发框架，旨在提高开发人员的开发效率以及系统的可维护性。\n我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。")]),r._v(" "),t("p",[r._v("比如说 Spring 自带 IoC（Inverse of Control:控制反转） 和 AOP(Aspect-Oriented Programming:面向切面编程)、可以很方便地对数据库进行访问、可以很方便地集成第三方组件（电子邮件，任务，调度，缓存等等）、对单元测试支持比较好、支持 RESTful Java 应用程序的开发。\nSpring 官网：https://spring.io/")]),r._v(" "),t("h2",{attrs:{id:"spring-模块"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-模块"}},[r._v("#")]),r._v(" Spring 模块")]),r._v(" "),t("p",[t("img",{attrs:{src:s(524),alt:"image"}})]),r._v(" "),t("h3",{attrs:{id:"spring-core"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-core"}},[r._v("#")]),r._v(" Spring Core")]),r._v(" "),t("p",[r._v("核心模块， Spring 其他所有的功能基本都需要依赖于该类库，主要提供 IoC 依赖注入功能的支持。")]),r._v(" "),t("h3",{attrs:{id:"spring-aspects"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-aspects"}},[r._v("#")]),r._v(" Spring Aspects")]),r._v(" "),t("p",[r._v("该模块为与 AspectJ(切面) 的集成提供支持。")]),r._v(" "),t("h3",{attrs:{id:"spring-aop"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-aop"}},[r._v("#")]),r._v(" Spring AOP")]),r._v(" "),t("p",[r._v("提供了面向切面的编程实现。")]),r._v(" "),t("h3",{attrs:{id:"spring-data-access-integration"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-data-access-integration"}},[r._v("#")]),r._v(" Spring Data Access/Integration ：")]),r._v(" "),t("p",[r._v("Spring Data Access/Integration 由 5 个模块组成：")]),r._v(" "),t("ul",[t("li",[r._v("spring-jdbc : 提供了对数据库访问的抽象 JDBC。不同的数据库都有自己独立的 API 用于操作数据库，而 Java 程序只需要和 JDBC API 交互，这样就屏蔽了数据库的影响。")]),r._v(" "),t("li",[r._v("spring-tx : 提供对事务的支持。")]),r._v(" "),t("li",[r._v("spring-orm : 提供对 Hibernate 等 ORM 框架的支持。")]),r._v(" "),t("li",[r._v("spring-oxm ： 提供对 Castor 等 OXM 框架的支持。")]),r._v(" "),t("li",[r._v("spring-jms : Java 消息服务。")])]),r._v(" "),t("h3",{attrs:{id:"spring-web"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-web"}},[r._v("#")]),r._v(" Spring Web")]),r._v(" "),t("p",[r._v("Spring Web 由 4 个模块组成：")]),r._v(" "),t("ul",[t("li",[r._v("spring-web ：对 Web 功能的实现提供一些最基础的支持。")]),r._v(" "),t("li",[r._v("spring-webmvc ： 提供对 Spring MVC 的实现。")]),r._v(" "),t("li",[r._v("spring-websocket ： 提供了对 WebSocket 的支持，WebSocket 可以让客户端和服务端进行双向通信。")]),r._v(" "),t("li",[r._v("spring-webflux ：提供对 WebFlux 的支持。WebFlux 是 Spring Framework 5.0 中引入的新的响应式框架。与 Spring MVC 不同，它不需要 Servlet API，是完全异步.")])]),r._v(" "),t("h3",{attrs:{id:"spring-test"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-test"}},[r._v("#")]),r._v(" Spring Test")]),r._v(" "),t("p",[r._v("Spring 团队提倡测试驱动开发（TDD）。有了控制反转 (IoC)的帮助，单元测试和集成测试变得更简单。")]),r._v(" "),t("p",[r._v("Spring 的测试模块对 JUnit（单元测试框架）、TestNG（类似 JUnit）、Mockito（主要用来 Mock 对象）、PowerMock（解决 Mockito 的问题比如无法模拟 final, static， private 方法）等等常用的测试框架支持的都比较好。")]),r._v(" "),t("h2",{attrs:{id:"spring-ioc-aop"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-ioc-aop"}},[r._v("#")]),r._v(" Spring IOC & AOP")]),r._v(" "),t("h3",{attrs:{id:"ioc-inverse-of-control-控制反转"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ioc-inverse-of-control-控制反转"}},[r._v("#")]),r._v(" IoC（Inverse of Control:控制反转）")]),r._v(" "),t("p",[r._v("IoC（Inverse of Control:控制反转） 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spirng 特有，在其他语言中也有应用。")]),r._v(" "),t("ul",[t("li",[r._v("控制 ：指的是对象创建（实例化、管理）的权力")]),r._v(" "),t("li",[r._v("反转 ：控制权交给外部环境（Spring 框架、IoC 容器）")])]),r._v(" "),t("p",[t("img",{attrs:{src:s(525),alt:"image"}})]),r._v(" "),t("p",[r._v("将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。")]),r._v(" "),t("p",[r._v("在实际项目中一个 Service 类可能依赖了很多其他的类，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。")]),r._v(" "),t("p",[r._v("在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。")]),r._v(" "),t("p",[r._v("Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。")]),r._v(" "),t("h3",{attrs:{id:"aop-aspect-oriented-programming-面向切面编程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#aop-aspect-oriented-programming-面向切面编程"}},[r._v("#")]),r._v(" AOP(Aspect-Oriented Programming:面向切面编程)")]),r._v(" "),t("p",[r._v("AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。\nSpring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 JDK Proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 Cglib ，这时候 Spring AOP 会使用 Cglib 生成一个被代理对象的子类来作为代理，如下图所示：")]),r._v(" "),t("p",[t("img",{attrs:{src:s(526),alt:"image"}})]),r._v(" "),t("p",[r._v("当然你也可以使用 AspectJ ！Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。")]),r._v(" "),t("h2",{attrs:{id:"spring-aop-和-aspectj-aop-有什么区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-aop-和-aspectj-aop-有什么区别"}},[r._v("#")]),r._v(" Spring AOP 和 AspectJ AOP 有什么区别？")]),r._v(" "),t("p",[r._v("Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。 Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。")]),r._v(" "),t("p",[r._v("Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，")]),r._v(" "),t("p",[r._v("如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多。")]),r._v(" "),t("h2",{attrs:{id:"spring-bean"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-bean"}},[r._v("#")]),r._v(" Spring bean")]),r._v(" "),t("ul",[t("li",[r._v("什么是 bean？"),t("br"),r._v("\n简单来说，bean 代指的就是那些被 IoC 容器所管理的对象。"),t("br"),r._v("\n我们需要告诉 IoC 容器帮助我们管理哪些对象，这个是通过配置元数据的定义的。配置元数据可以是 XML 文件、注解或者 Java 配置类。")])]),r._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token operator"}},[r._v("<")]),t("span",{pre:!0,attrs:{class:"token operator"}},[r._v("!")]),t("span",{pre:!0,attrs:{class:"token operator"}},[r._v("--")]),r._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[r._v("Constructor")]),t("span",{pre:!0,attrs:{class:"token operator"}},[r._v("-")]),r._v("arg "),t("span",{pre:!0,attrs:{class:"token keyword"}},[r._v("with")]),r._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[r._v("'value'")]),r._v(" attribute "),t("span",{pre:!0,attrs:{class:"token operator"}},[r._v("--")]),t("span",{pre:!0,attrs:{class:"token operator"}},[r._v(">")]),r._v("\n"),t("span",{pre:!0,attrs:{class:"token operator"}},[r._v("<")]),r._v("bean id"),t("span",{pre:!0,attrs:{class:"token operator"}},[r._v("=")]),t("span",{pre:!0,attrs:{class:"token string"}},[r._v('"..."')]),r._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[r._v("class")]),t("span",{pre:!0,attrs:{class:"token operator"}},[r._v("=")]),t("span",{pre:!0,attrs:{class:"token string"}},[r._v('"..."')]),t("span",{pre:!0,attrs:{class:"token operator"}},[r._v(">")]),r._v("\n   "),t("span",{pre:!0,attrs:{class:"token operator"}},[r._v("<")]),r._v("constructor"),t("span",{pre:!0,attrs:{class:"token operator"}},[r._v("-")]),r._v("arg value"),t("span",{pre:!0,attrs:{class:"token operator"}},[r._v("=")]),t("span",{pre:!0,attrs:{class:"token string"}},[r._v('"..."')]),t("span",{pre:!0,attrs:{class:"token operator"}},[r._v("/")]),t("span",{pre:!0,attrs:{class:"token operator"}},[r._v(">")]),r._v("\n"),t("span",{pre:!0,attrs:{class:"token operator"}},[r._v("<")]),t("span",{pre:!0,attrs:{class:"token operator"}},[r._v("/")]),r._v("bean"),t("span",{pre:!0,attrs:{class:"token operator"}},[r._v(">")]),r._v("\n")])]),r._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[r._v("1")]),t("br"),t("span",{staticClass:"line-number"},[r._v("2")]),t("br"),t("span",{staticClass:"line-number"},[r._v("3")]),t("br"),t("span",{staticClass:"line-number"},[r._v("4")]),t("br")])]),t("p",[r._v("下图简单地展示了 IoC 容器如何使用配置元数据来管理对象。")])])}),[],!1,null,null,null);a.default=e.exports}}]);